from next_gen_attribution.modeling.attribution import Attribution


class Markov_Attribution(Attribution):
    def __init__(
        self,
        workflow_mode: str = "dev",
        data_source: str = "local",
        model_version: str = "main_20221121",
    ):
        super().__init__(
            "markov",
            "tours",
            workflow_mode,
            data_source,
            model_version,
        )

        self.journey_node_group_dict = self.load_journey_node_group()

    def _increment_node(A: np.ndarray, from_node, to_node):
        # Will this cause potential bugs?
        A[
            self.journey_node_group_dict[from_node],
            self.journey_node_group_dict[to_node]
        ] += 1
        return A

    def _calculate_markov_dropout(self, journey_col: str, dropout_nodes: list):
        # Refactor method as function?
        A = np.zeros((len(self.journey_node_group_dict), len(self.journey_node_group_dict)))

        # TODO: Improve algorithm
        for _, row in filtered.iterrows():
            if len(row[journey_col]) != 0:
                row_len = len(row[journey_col])
                for i in range(row_len):
                    current_node = row[journey_col][i]
                    if current_node in dropout_nodes:
                        break
                    if i == 0:
                        A = self.increment_node(A, "start", current_node)
                        try:
                            next_node = row[journey_col][i + 1]
                            if next_node is None:
                                break
                            # If last node
                            # TODO: Fix if last one doesn't match
                        except IndexError:
                            if row["isLead"]:
                                A = self.increment_node(A, "start", "lead")
                            else:
                                A = self.increment_node(A, "start", "null")
                        else:
                            A = self.increment_node(A, "start", next_node)

    def _calculate_all_markov_dropout(self, journey_col: str):
        markov_dropout_dict = {
            # No nodes are dropped
            # Is this good form?
            None: self._calculate_markov_dropout(journey_col, []),
            **{
                node_group_name: self._calculate_markov_dropout(journey_col, dropout_nodes)
                for node_group_name, dropout_nodes in self.journey_node_group_dict.items()
            }
        }

    # TODO: Add counting of dropout

    def train(self) -> None:
        # HB: (Matthew collaboration!)
        self._logger.info(f"Getting preprocessed data")
        data = self._get_data()

        self._logger.info(f"Picking touchpoints from data")
        self._pick_touchpoints(data)

        self._logger.info(
            "Computing the observed sum of conversions generated by each journey vector"
        )
        jvector_conversion_df = self._journey_vector_conversions(data)
        self._logger.info(
            f"{len(jvector_conversion_df.loc[jvector_conversion_df['conversions']>0])} out of {len(jvector_conversion_df)} user journey types have generated some conversions"
        )

        self._logger.info("Calculating Markov dropout for all node groups")
        self._calculate_all_markov_dropout("jvector")
